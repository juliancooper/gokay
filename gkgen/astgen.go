package gkgen

import (
	"bytes"
	"fmt"
	"go/ast"
	"io"
	"reflect"
	"sort"

	"strings"

	"github.com/davecgh/go-spew/spew"
)

// ValidateASTGenerator holds a map of identifiers and ASTGenerater's
type ValidateASTGenerator struct {
	Generators map[string]ASTGenerater
}

// AddValidation adds a Validation to a ValidateGenerator, that Validation can be applied to a struct
// field using the string returned by
// validater.Name()
func (s *ValidateASTGenerator) AddValidation(g ASTGenerater) error {
	s.Generators[g.Name()] = g
	return nil
}

// NewValidateGenerator creates a new pointer value of type ValidateGernerator
// - Hex: checks if a string is a valid hexadecimal format number
// - Length: takes 1 integer argument and compares the length of a string field against that
// - NotNil: Validate fails if field is nil
// - UUID: Checks and fails if a string is not a valid UUID
func NewValidateASTGenerator() *ValidateASTGenerator {
	v := &ValidateASTGenerator{make(map[string]ASTGenerater)}
	// v.AddValidation(NewNotNilValidator())
	// v.AddValidation(NewLengthValidator())
	v.AddValidation(NewHexValidator())
	// v.AddValidation(NewUUIDValidator())
	// v.AddValidation(NewBCP47Validator())
	return v
}

// ASTGenerater defines the behavior of types that generate validation code
type ASTGenerater interface {
	ASTGenerate(*ast.Field, []string) (string, error)
	Name() string
}

// Generate writes a Validate function using a go abstract syntax tree
func (s *ValidateASTGenerator) Generate(out io.Writer, f *ast.File) error {
	// TODO: Do not generate empty Validate functions

	// Output should deterministic
	sortedObjectKeys := make([]string, len(f.Scope.Objects))
	for k := range f.Scope.Objects {
		sortedObjectKeys = append(sortedObjectKeys, k)
	}
	sort.Strings(sortedObjectKeys)

	fmt.Fprint(out, "// Code in this file generated by gokay: github.com/zencoder/gokay\n")
	fmt.Fprintf(out, "package %s\n", f.Name)

	for _, k := range sortedObjectKeys {
		if k == "" {
			continue
		}
		d := f.Scope.Objects[k]
		ts, ok := d.Decl.(*ast.TypeSpec)
		if !ok {
			continue
		}
		st, ok := ts.Type.(*ast.StructType)
		if !ok {
			continue
		}

		svBuf := &bytes.Buffer{}
		// hasValidation := false

		fmt.Fprintf(svBuf, "func(s %s) Validate() error {\n", ts.Name)
		fmt.Fprint(svBuf, "\tem := make(gokay.ErrorMap)\n\n")

		for _, field := range st.Fields.List {
			fvBuf := &bytes.Buffer{}
			// fieldIsValidated := false

			reflectTag := reflect.StructTag(strings.Trim(field.Tag.Value, "`"))
			fmt.Println(reflectTag)
			gokayTag := reflectTag.Get("valid")

			vcs, _ := ParseTag(gokayTag)
			spew.Dump(vcs)

			fmt.Fprintf(fvBuf, `
	// BEGIN %[1]s field Validations
	errors%[1]s := make(gokay.ErrorSlice, 0, 0)
	`, field.Names[0])

			for _, vc := range vcs {
				if _, ok := s.Generators[vc.Name()]; !ok {
					return fmt.Errorf("Unknown validation generator name: '%s'", vc.Name())
				}
				code, err := s.Generators[vc.Name()].ASTGenerate(field, vc.Params)
				fmt.Fprintf(fvBuf, "// '%s' Validation", vc.Name())
				fmt.Fprintln(fvBuf, code)
				if err != nil {
					return err
				}
			}

			fmt.Fprintf(fvBuf, `
		if len(errors%[1]s) > 0 {
			em["%[1]s"] = errors%[1]s
		}
		`, field.Names[0])

			fmt.Fprintf(fvBuf, "// END %s field Validations\n", field.Names[0])

			// TODO: Parse Validations

			// TODO: Implicit Validations

			// TODO: (Implicit) Struct field validation

			// TODO: (Implicit) Map of struct validation (maybe dumpt this feature)

			// TODO: (Implicit) Slice of struct validation

			// if fieldIsValidated {
			svBuf.Write(fvBuf.Bytes())
			// hasValidation = true
			// }
		}

		// TODO: Implicit Validations for each field

		// switch ts.Type.(type) {
		// case *ast.StructType:

		// fmt.Fprintf(out, "if err := v.Generate(out, %s.%s{}); err != nil {\npanic(err.Error())\n}\n", f.Name.String(), ts.Name.String())
		// }

		fmt.Fprintln(svBuf, `
	if len(em) > 0 {
		return em
	} else {
		return nil
	}
	`)
		fmt.Fprintln(svBuf, "}")
		// if hasValidation {
		out.Write(svBuf.Bytes())
		// }
	}

	return nil
}
